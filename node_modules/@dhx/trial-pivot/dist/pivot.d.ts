declare namespace pivot{
type TDataBlock = {
    in: string[];
    out: string[];
    exec: any;
    length?: number;
};
type TDataConfig = TDataBlock[];
interface IEventConfig {
    intercept?: boolean;
    tag?: number | string | symbol;
}
interface DataHash {
    [key: string]: any;
}
interface IWritable<T> {
    subscribe: (fn: (v: T) => any) => any;
    update: (fn: (v: T) => any) => any;
    set: (val: T) => any;
}
type TTrigger<T> = (v: T) => any;
type SomeCallback = () => void;
type TAsyncSignals = {
    [key: string]: SomeCallback | null;
};
interface IPublicWritable<T> {
    subscribe: (fn: TTrigger<T>) => any;
    __trigger(): void;
    __parse: (val: T, key: string, signals: TAsyncSignals, mode: TStateMode) => void;
}
type TWritableCreator = (val: any) => IWritable<typeof val>;
interface IEventBus<T> {
    exec(name: string, ev: T[keyof T]): Promise<T[keyof T]>;
    setNext(next: IEventBus<T>): IEventBus<T>;
}
type TStateMode = number;

class EventBus<T, A extends keyof T> {
    private _handlers;
    protected _nextHandler: IEventBus<T>;
    protected _tag: WeakMap<{
        (v: T[A]): void | boolean | Promise<boolean>;
    }, number | string | symbol>;
    constructor();
    on(name: A, handler: (v: T[A]) => void | boolean | Promise<boolean>, config?: IEventConfig): void;
    intercept(name: A, handler: (v: T[A]) => void | boolean | Promise<boolean>, config?: IEventConfig): void;
    detach(tag: number | string | symbol): void;
    exec(name: A, ev: T[A]): Promise<T[A]>;
    setNext(next: IEventBus<T>): IEventBus<T>;
}

type TState<Type> = {
    [Property in keyof Type]: IPublicWritable<Type[Property]>;
};
class Store<T extends DataHash> {
    private _state;
    private _values;
    private _writable;
    private _async;
    constructor(config: any);
    setState(data: Partial<T>, mode?: TStateMode | TDataConfig): TAsyncSignals;
    getState(): T;
    getReactive(): TState<T>;
    private _wrapProperties;
    private _wrapNested;
    private _wrapWritable;
}

type TMethodsConfig = IDataMethodsConfig;
interface IMethodsHash {
    [key: string]: any;
}
interface IDataConfig {
    data: Record<string, any>[];
    config: IConfig;
    fields: TField[];
    tableConfig?: any;
    activeFilter?: any;
    columnShape?: IColumnShape;
    headerShape?: IHeaderShape;
    tableShape?: ITableShape;
    methods?: IMathMethods;
    configPanel?: boolean;
    predicates?: IPredicatesHash;
    readonly?: boolean;
    limits?: ILimits;
    filters?: IFilteringRules;
}
interface IData {
    data: Record<string, any>[];
    config: IParsedConfig;
    fields: TField[];
    tableConfig: any;
    activeFilter: any;
    columnShape: IColumnShape;
    headerShape: IHeaderShape;
    tableShape: ITableShape;
    methods: IMathMethods;
    configPanel: boolean;
    predicates: IPredicatesHash;
    readonly: boolean;
    limits: ILimits;
    filters: IFilteringRules;
}
interface IApi {
    exec: (action: keyof TMethodsConfig, params: any) => Promise<any>;
    on: (action: keyof TMethodsConfig, callback: (config: any) => any) => void;
    intercept: (action: keyof TMethodsConfig, callback: (config: any) => any) => void;
    getState: () => IData;
    getReactiveState: () => {
        [Key in keyof IData]: IPublicWritable<IData[Key]>;
    };
    setNext: (ev: IEventBus<TMethodsConfig>) => void;
    getStores: () => {
        data: DataStore;
    };
    getTable: <W extends boolean>(waitRender?: W) => W extends true ? Promise<any> : any;
}
interface IDataHash<T> {
    [key: string]: T;
}
interface IConfig {
    values?: TConfigField[];
    rows?: TConfigField[];
    columns?: TConfigField[];
    filters?: IFilters;
}
interface IParsedConfig {
    values: TProcessedField[];
    rows: TProcessedField[];
    columns: TProcessedField[];
    filters?: IFilters;
    _ready: boolean;
}
interface ITableConfig {
    columns?: any[];
    data?: any[];
    footer?: boolean;
    sizes?: ISizes;
    split?: {
        left?: number;
    };
    tree?: boolean;
    cellStyle?: (row: any, col: any) => string;
}
interface IHeaderShape {
    collapsible?: boolean;
    vertical?: boolean;
    template?: (label: string, fieldId: string, subLabel?: string) => string;
}
interface ILimits {
    rows?: number;
    columns?: number;
    raws?: number;
}
interface ISizes {
    rowHeight?: number;
    headerHeight?: number;
    colWidth?: number;
    footerHeight?: number;
}
interface ITableShape {
    templates?: {
        [fieldName: string]: (value: any, operation: string) => any;
    };
    sizes?: ISizes;
    totalRow?: boolean | "sumOnly";
    totalColumn?: boolean | "sumOnly";
    marks?: {
        [cssClass: string]: ((v: any, columnData: any, rowData: any) => boolean) | "max" | "min";
    };
    tree?: boolean;
    cleanRows?: boolean;
    dateToString?: (value: Date) => string;
    split?: {
        left: boolean;
    };
}
interface IColumnShape {
    width?: Record<string, number>;
    autoWidth?: {
        columns: {
            [field: string]: boolean;
        };
        auto: boolean | "header" | "data";
        maxRows?: number;
        firstOnly?: boolean;
    };
    sort?: boolean;
}
type TMathMethod = (values: number[] | string[] | Date[]) => any;
interface IMathMethodData {
    handler?: TMathMethod;
    type?: string | string[];
    label?: string;
    branchMode?: "raw" | "result";
    branchMath?: string;
}
interface IMathMethods {
    [key: string]: IMathMethodData;
}
interface IDefaultPredicate {
    label: string | ((type: any) => string);
    type: string | string[];
    filter?: IDataHash<any>;
}
interface IPredicate {
    handler: (value: any) => any;
    type: string | string[];
    filter?: IDataHash<any>;
    label?: string | ((type: any) => string);
    template?: (value: any, locale?: any) => string;
    field?: (value: string) => boolean;
}
interface IPredicatesHash {
    [key: string]: IPredicate;
}
type TFilterHandler<T, K> = ((a: T, b: K) => boolean) | string;
type TDatesRange = {
    start: Date;
    end: Date;
};
type IFilteringRules = {
    number: {
        [key: string]: TFilterHandler<number, number>;
    };
    text: {
        [key: string]: TFilterHandler<string, string>;
    };
    date: {
        [key: string]: TFilterHandler<Date, Date | TDatesRange>;
    };
    tuple: {
        [key: string]: TFilterHandler<number, number>;
    };
};
type TAreaType = "columns" | "values" | "rows";
type TMethodType = "number" | "date" | "text";
type sortHandler<T> = {
    (a: T, b: T): number;
};
type TField = {
    id: string;
    type: TMethodType;
    label?: string;
    sort?: "asc" | "desc" | sortHandler<string | number | Date>;
};
interface IConfigField {
    field: string;
    method?: string | null;
}
type TConfigField = string | IConfigField;
type TProcessedField = {
    id: string;
    area: TAreaType;
    field: string;
    type: TMethodType;
    label?: string;
    method?: string | null;
    base?: string;
};
interface IFilters {
    [key: string]: any;
}

class DataStore extends Store<IData> {
    in: EventBus<TMethodsConfig, keyof TMethodsConfig>;
    private _router;
    private _analytic;
    private _tableId;
    constructor(w: TWritableCreator);
    init(state: Partial<IDataConfig>): void;
    setState(state: Partial<IData>, ctx?: TDataConfig): TAsyncSignals;
    setStateAsync(state: Partial<IData>): void;
    protected _calculateData(config: IParsedConfig): {
        columns: any[];
        data: any[];
        sizes: ISizes;
        tree: boolean;
        footer: boolean;
        split: {
            left: number;
        };
        cellStyle: (row: any, column: any) => string;
    };
    private _getHeaderTemplate;
    private _addFilters;
    protected _setDimensions(fields: TField[], predicates: IMethodsHash): void;
    private _getPredicates;
    private _getColumns;
    private _getColumnTemplate;
    private _applyHeaderShape;
    private _applyColumnMeta;
    private _getTotalColumns;
    private _getPredicateTemplate;
    private _getRowProxy;
    private _getRows;
    private _getNestedRows;
    private _getFilters;
    protected _prepareConfig(config: IConfig, fields: TField[]): IParsedConfig;
    private _createUniqueField;
    private _validateUniqueField;
    private _removeDuplicatedFields;
    private _checkDuplicatedFields;
    private _updateConfig;
    private _getConfigCopy;
    private _setMathMethods;
}
interface IDataMethodsConfig {
    ["add-field"]: {
        id?: string;
        area: TAreaType;
        field: string;
        method: string | null;
    };
    ["update-field"]: {
        id: string;
        area: TAreaType;
        method: string | null;
    };
    ["move-field"]: {
        area: TAreaType;
        id: string;
        before?: string;
        after?: string;
    };
    ["delete-field"]: {
        id: string;
        area: TAreaType;
    };
    ["open-filter"]: {
        id: string | null;
        area?: TAreaType;
    };
    ["apply-filter"]: {
        rule: any;
    };
    ["update-config"]: IConfig | IParsedConfig;
    ["show-config-panel"]: {
        mode: boolean;
    };
    ["render-table"]: {
        config: ITableConfig;
    };
}

const defaultMethods: IMathMethods;

const defaultPredicates: {
    [key: string]: IDefaultPredicate;
};

type TThemeConfig = {
    name: string;
    fonts: boolean;
};
interface IPivotConfig extends Omit<IDataConfig, "tableConfig" | "activeFilter"> {
    locale?: Record<string, any>;
    theme?: TThemeConfig;
}

class Pivot {
    api: IApi;
    config: IPivotConfig;
    container: HTMLElement;
    private _pivot;
    constructor(container: HTMLElement, config: IPivotConfig);
    destructor(): void;
    setConfig(config: Partial<IPivotConfig>): void;
    getTable<W extends boolean>(waitRender?: W): W extends true ? Promise<any> : any;
    showConfigPanel(config: TMethodsConfig["show-config-panel"]): void;
    setLocale(locale: Record<string, any>): void;
    private _init;
}

const locales: {
    en: any;
    cn: any;
    de: any;
};

export { Pivot, defaultMethods, defaultPredicates, locales };
}